
# Tables Created by Identity Framework

**Identity Framework** manages user authentication and role management. Below are the main tables created by this framework:

### AspNetUsers
- This table contains information about the application’s users. It stores data such as user ID, username, hashed password, security information (like password recovery questions), and other properties such as email, phone numbers, and associated tokens.

### AspNetRoles
- This table contains roles assigned to users. For example, roles could be "Administrator," "User," etc. Each row in this table contains the role ID and name.

### AspNetUserRoles
- This table links users to roles. It associates each user with one or more roles via their respective IDs (User ID and Role ID).

### AspNetUserClaims
- This table stores claims associated with each user. Claims are statements about a user (for example, their age or rights). Each entry contains the type and value of the claim for a given user.

### AspNetUserLogins
- This table stores information about external logins for a user (for example, via Google or Facebook). Each entry stores the user ID, login provider, and the external ID provided by the provider.

### AspNetUserTokens
- This table stores authentication tokens associated with users, including access tokens or refresh tokens. Each entry contains the user ID, token type, and value.

### AspNetRoleClaims
- This table stores claims associated with roles. This allows attaching certain claims to a specific role, which then applies to all users in that role.

---

# Tables Created by IdentityServer4

In addition to Identity Framework, **IdentityServer4** manages authentication and authorization for client applications and APIs. The following tables are generated by IdentityServer4:

### ApiResources
- This table contains information about the APIs protected by IdentityServer4. It stores details such as the API name, description, and status (active or inactive).

### ApiScopes
- This table defines authorization scopes that clients can request to access API resources. Scopes determine the level of privileges required to access certain parts of an API.

### Clients
- This table contains information about clients (applications) interacting with IdentityServer4. Clients can be web apps, mobile apps, or backend services. It stores details such as client ID, secrets, redirect URIs, and supported OAuth2 flow types.

### ClientSecrets
- This table stores secrets associated with each client. These secrets are used to verify the client’s identity during authentication requests.

### PersistedGrants
- This table stores tokens (such as access and refresh tokens) and user consent permissions. The information is persisted to enable long-term management of tokens and their revocation.

### DeviceFlowCodes
- This table is used to store codes related to device authentication flow. It contains necessary information to authenticate devices, often used in scenarios with limited user interfaces (such as TVs or consoles).

### IdentityResources
- This table contains identity resources (such as "openid", "profile", "email") representing user information that can be protected and issued as identity tokens.

---

# Configuration with Duende IdentityServer

The configuration of **Duende IdentityServer** with **ASP.NET Identity** and **Entity Framework** involves integrating two types of stores: the **ConfigurationStore** and the **OperationalStore**. These stores ensure the persistence of data related to clients, APIs, scopes, and tokens.

Below is an example configuration in C# using **SQLite** for persistence:

```csharp
// Configure authentication
services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();

// Configure IdentityServer
services.AddIdentityServer()
    .AddAspNetIdentity<ApplicationUser>()
    .AddConfigurationStore(options =>
    {
        options.ConfigureDbContext = b =>
            b.UseSqlite(connectionString, dbOpts => dbOpts.MigrationsAssembly(typeof(Program).Assembly.FullName));
    })
    .AddOperationalStore(options =>
    {
        options.ConfigureDbContext = b =>
            b.UseSqlite(connectionString, dbOpts => dbOpts.MigrationsAssembly(typeof(Program).Assembly.FullName));
    })
// For development only
    .AddDeveloperSigningCredential();
```